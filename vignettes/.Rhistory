dim(annot)
dim(fd_table)
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = counts), colData=annot)
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = counts))
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = as.matrix(counts)))
# Read the dataset
counts = read.delim(file.path(input_dir,"pbmc_example_counts.txt"),sep="\t")
# if we have genes that are not expressed in any cell, discard them
keep_feature = !gene_filter_by_feature_count(counts,0)
counts = counts[keep_feature,]
# make a table of metadata (e.g. batch, cell type annotation,treatment,...)
# Here, we do not have any such information, so we just give each cell a name
# Note that the rownames of this table have to correspond to the column names
# of the count matrix.
cell_annotation = data.frame(cell_idx=paste0("pbmc_C",seq(dim(counts)[2])))
rownames(cell_annotation) = colnames(counts)
# get gene annotations from ensembldb
# optional: get gene descriptions from org.Hs.eg.db (slows down the process a lot!)
# NOTE: the output of get_gene_annotations is a data.table sorted by gene identifier.
#       This means the genes are no longer in the same order as in the count matrix!
gene_annotations = get_gene_annotations(rownames(counts),organism = "human",get_descriptions = F)
# convert this to feature metadata
feature_annotation = as.data.frame(gene_annotations)
rownames(feature_annotation) = gene_annotations$gene_id
feature_annotation = feature_annotation[rownames(counts),]
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = as.matrix(counts)),
colData = cell_annotation,
rowData = feature_annotation)
#calculate QC metrics
sce = calculateQCMetrics(sce,feature_controls = list(MT=which(rowData(sce)$chr=="MT")))
?calculateQCMetrics
# Read the dataset
counts = read.delim(file.path(input_dir,"pbmc_example_counts.txt"),sep="\t")
# if we have genes that are not expressed in any cell, discard them
keep_feature = !gene_filter_by_feature_count(counts,0)
counts = counts[keep_feature,]
# make a table of metadata (e.g. batch, cell type annotation,treatment,...)
# Here, we do not have any such information, so we just give each cell a name
# Note that the rownames of this table have to correspond to the column names
# of the count matrix.
cell_annotation = data.frame(cell_idx=paste0("pbmc_C",seq(dim(counts)[2])))
rownames(cell_annotation) = colnames(counts)
# get gene annotations from ensembldb
# optional: get gene descriptions from org.Hs.eg.db (slows down the process a lot!)
# NOTE: the output of get_gene_annotations is a data.table sorted by gene identifier.
#       This means the genes are no longer in the same order as in the count matrix!
gene_annotations = get_gene_annotations(rownames(counts),organism = "human",get_descriptions = F)
# convert this to feature metadata
feature_annotation = as.data.frame(gene_annotations)
rownames(feature_annotation) = gene_annotations$gene_id
feature_annotation = feature_annotation[rownames(counts),]
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = as.matrix(counts)),
colData = cell_annotation,
rowData = feature_annotation)
#calculate QC metrics
sce = calculateQCMetrics(sce,feature_controls = list(MT=which(rowData(sce)$chr=="MT")), compact = TRUE)
names(sce)
names(colData(sce))
names(rowData(sce))
biocLite("org.Hs.eg.db")
# assign cell cycle phase (based on the method from scran)
# because PBMCs are post-mitotic, most cells should be assigned to G0/G1 phase
cc = annotate_cell_cycle(sce)
sce$cell_cycle_phase = cc$phases
sce$cc_scores = cc$scores
names(colData(sce))
#save the SCESet
save(sce,file=file.path(out_data_dir,"sce_raw.RData"))
p1 = plotQC(sce, type="high",feature_names_to_plot = "symbol")
print(p1)
p1.2 = custom_plotHighestExprs(sce,feature_names_to_plot = "symbol")
source('~/scRNAseq_workflow/code/scrnaseq_workflow_Plotting.R', echo=TRUE)
p1.2 = custom_plotHighestExprs(sce,feature_names_to_plot = "symbol")
source(file.path(code_dir,"scRNASeq_pipeline_functions.R"))
p1.2 = custom_plotHighestExprs(sce,feature_names_to_plot = "symbol")
source(file.path(code_dir,"scRNASeq_pipeline_functions.R"))
p1.2 = custom_plotHighestExprs(sce,feature_names_to_plot = "symbol")
source(file.path(code_dir,"scRNASeq_pipeline_functions.R"))
p1.2 = custom_plotHighestExprs(sce,feature_names_to_plot = "symbol")
?plotQC
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F)
p1.2 = p1.2 + xlab("Expression [raw counts, log2]")
print(p1.2)
p1.2 = p1.2 + xlab("Expression [raw counts]") + scale_x_log10()
print(p1.2)
p2 = plotQC(sce, type = "exprs-freq-vs-mean")
p2 = p2+xlab("Mean expression [raw counts, log2]")+ggtitle("Mean expression versus detection rate")
print(p2)
# Check total number of zeroes
t = table(counts(sce)==0)
print(t/sum(t)*100)
p3 = plotQC(sce, type="find", variable="total_features")
p3 = plotQC(sce, type="find", variable="total_features_by_counts")
?plotQC
p3 = plotQC(sce, type="find_pcs", variable="total_features")
p3 = plotQC(sce, type="find-pcs", variable="total_features")
# Read the dataset
counts = read.delim(file.path(input_dir,"pbmc_example_counts.txt"),sep="\t")
# if we have genes that are not expressed in any cell, discard them
keep_feature = !gene_filter_by_feature_count(counts,0)
counts = counts[keep_feature,]
# make a table of metadata (e.g. batch, cell type annotation,treatment,...)
# Here, we do not have any such information, so we just give each cell a name
# Note that the rownames of this table have to correspond to the column names
# of the count matrix.
cell_annotation = data.frame(cell_idx=paste0("pbmc_C",seq(dim(counts)[2])))
rownames(cell_annotation) = colnames(counts)
# get gene annotations from ensembldb
# optional: get gene descriptions from org.Hs.eg.db (slows down the process a lot!)
# NOTE: the output of get_gene_annotations is a data.table sorted by gene identifier.
#       This means the genes are no longer in the same order as in the count matrix!
gene_annotations = get_gene_annotations(rownames(counts),organism = "human",get_descriptions = F)
# convert this to feature metadata
feature_annotation = as.data.frame(gene_annotations)
rownames(feature_annotation) = gene_annotations$gene_id
feature_annotation = feature_annotation[rownames(counts),]
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = as.matrix(counts), logcounts=log2(counts+1)),
colData = cell_annotation,
rowData = feature_annotation)
#calculate QC metrics
sce = calculateQCMetrics(sce,feature_controls = list(MT=which(rowData(sce)$chr=="MT")), compact = TRUE)
# assign cell cycle phase (based on the method from scran)
# because PBMCs are post-mitotic, most cells should be assigned to G0/G1 phase
cc = annotate_cell_cycle(sce)
sce$cell_cycle_phase = cc$phases
sce$cc_scores = cc$scores
#save the SCESet
save(sce,file=file.path(out_data_dir,"sce_raw.RData"))
load(file.path(out_data_dir,"sce_raw.RData"))
p1 = plotQC(sce, type="high",feature_names_to_plot = "symbol")
print(p1)
?plotHighestExprs
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F, exprs_values ="logcounts")
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F)
p1.2 = p1.2 + xlab("Expression [raw counts, log2]")
print(p1.2)
# to save a plot, use the ggsave function:
ggsave(p1.2, file = "saved_example_plot.pdf",height=7,width=7)
colnames(sce)
p3 = plotQC(sce, type="find-pcs", variable="total_features")
sce =SingleCellExperiment(assays = list(counts = as.matrix(counts), logcounts=log2(as.matrix(counts)+1)),
colData = cell_annotation,
rowData = feature_annotation)
#calculate QC metrics
sce = calculateQCMetrics(sce,feature_controls = list(MT=which(rowData(sce)$chr=="MT")), compact = TRUE)
# assign cell cycle phase (based on the method from scran)
# because PBMCs are post-mitotic, most cells should be assigned to G0/G1 phase
cc = annotate_cell_cycle(sce)
sce$cell_cycle_phase = cc$phases
sce$cc_scores = cc$scores
#save the SCESet
save(sce,file=file.path(out_data_dir,"sce_raw.RData"))
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F, exprs_vales="logcounts")
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F, exprs_values="logcounts")
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F, exprs_values="logcounts", by_exprs_values = "counts")
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F,exprs_values = "logcounts", colour_cells_by="tital_features_by_counts")
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F,exprs_values = "logcounts", colour_cells_by="total_features_by_counts")
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F,exprs_values = "logcounts", colour_cells_by=c("scater_qc","total_features_by_counts"))
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F,exprs_values = "logcounts", colour_cells_by=c("scater_qc","all","total_features_by_counts"))
p1.2 = p1.2 + xlab("Expression [raw counts, log2]")
print(p1.2)
p2 = plotQC(sce, type = "exprs-freq-vs-mean")
p2 = p2+xlab("Mean expression [raw counts, log2]")+ggtitle("Mean expression versus detection rate")
print(p2)
# Check total number of zeroes
t = table(counts(sce)==0)
print(t/sum(t)*100)
p3 = plotQC(sce, type="find-pcs", variable="total_features")
p3 = plotQC(sce, type="find-pcs", variable=c("scater_qc","all","total_features"))
p3 = plotQC(sce, type="find-pcs", variable=c("scater_qc","all","total_features"))
p3 = plotQC(sce, type="find-pcs", variable="total_features_by_counts"))
p3 = plotQC(sce, type="find-pcs", variable="total_features_by_counts")
?plotQC
rm(list=ls())
graphics.off()
wd = ".."
#Directory where input files are stored
input_dir = file.path(wd,"example_data")
#Directory where code is stored
code_dir = file.path(wd,"code")
#where to save the output data?
out_data_dir = file.path(wd,"example_output")
if(!dir.exists(out_data_dir)) {dir.create(out_data_dir)}
#where to save the produced plots?
plotdir = file.path(wd,"example_plots")
if(!dir.exists(plotdir)) {dir.create(plotdir)}
#path to your MCL binary
mcl_path = "~/local/bin/mcl"
set.seed(17) #to make tSNE plots reproducible
source(file.path(code_dir,"scRNASeq_pipeline_functions.R"))
# loading the libraries that are required throughout the analysis
library_calls()
# Read the dataset
counts = read.delim(file.path(input_dir,"pbmc_example_counts.txt"),sep="\t")
# if we have genes that are not expressed in any cell, discard them
keep_feature = !gene_filter_by_feature_count(counts,0)
counts = counts[keep_feature,]
# make a table of metadata (e.g. batch, cell type annotation,treatment,...)
# Here, we do not have any such information, so we just give each cell a name
# Note that the rownames of this table have to correspond to the column names
# of the count matrix.
cell_annotation = data.frame(cell_idx=paste0("pbmc_C",seq(dim(counts)[2])))
rownames(cell_annotation) = colnames(counts)
# get gene annotations from ensembldb
# optional: get gene descriptions from org.Hs.eg.db (slows down the process a lot!)
# NOTE: the output of get_gene_annotations is a data.table sorted by gene identifier.
#       This means the genes are no longer in the same order as in the count matrix!
gene_annotations = get_gene_annotations(rownames(counts),organism = "human",get_descriptions = F)
# convert this to feature metadata
feature_annotation = as.data.frame(gene_annotations)
rownames(feature_annotation) = gene_annotations$gene_id
feature_annotation = feature_annotation[rownames(counts),]
#construct SingleCellExperiment object
sce =SingleCellExperiment(assays = list(counts = as.matrix(counts), logcounts=log2(as.matrix(counts)+1)),
colData = cell_annotation,
rowData = feature_annotation)
#calculate QC metrics
sce = calculateQCMetrics(sce,feature_controls = list(MT=which(rowData(sce)$chr=="MT")), compact = FALSE)
# assign cell cycle phase (based on the method from scran)
# because PBMCs are post-mitotic, most cells should be assigned to G0/G1 phase
cc = annotate_cell_cycle(sce)
sce$cell_cycle_phase = cc$phases
sce$cc_scores = cc$scores
#save the SCESet
save(sce,file=file.path(out_data_dir,"sce_raw.RData"))
names(colData(sce))
p1.2 = plotHighestExprs(sce,feature_names_to_plot = "symbol",as_percentage=F,exprs_values = "logcounts", colour_cells_by=c("total_features_by_counts"))
p1.2 = p1.2 + xlab("Expression [raw counts, log2]")
print(p1.2)
# to save a plot, use the ggsave function:
ggsave(p1.2, file = "saved_example_plot.pdf",height=7,width=7)
p2 = plotQC(sce, type = "exprs-freq-vs-mean")
p2 = p2+xlab("Mean expression [raw counts, log2]")+ggtitle("Mean expression versus detection rate")
print(p2)
# Check total number of zeroes
t = table(counts(sce)==0)
print(t/sum(t)*100)
p3 = plotQC(sce, type="find-pcs", variable="total_features_by_counts")
print(p3 + ggtitle("Correlation of principal components with total detected features."))
p3.2 = plotQC(sce, type="find", variable="cell_cycle_phase")
print(p3.2+ggtitle("Correlation of principal components with cell cycle phase."))
vars = c("total_counts","total_features_by_counts","cell_cycle_phase")
p4 = plotQC(sce, type="expl", variables=vars)
print(p4 + ggtitle("Percentage of explained variance"))
min_genes = 9.0 #minimum number of features (genes) per cell [log2]
min_UMI = 10.5  #minimum total UMIs / cell [log2]
mt_threshold = 9 #Maximum percentage of mitochondrial genes
plot_RNA_QC(sce, min_genes = min_genes, min_UMI = min_UMI)
plot_MT_QC(sce,mt_threshold)
sce$pct_counts_feature_controls_MT
names(colData(sce))
source('~/scRNAseq_workflow/code/scrnaseq_workflow_QC.R', echo=TRUE)
plot_RNA_QC(sce, min_genes = min_genes, min_UMI = min_UMI)
plot_MT_QC(sce,mt_threshold)
?plotPhenoData
source('~/scRNAseq_workflow/code/scrnaseq_workflow_QC.R')
plot_MT_QC(sce,mt_threshold)
names(colData(sce))
source('~/scRNAseq_workflow/code/scrnaseq_workflow_QC.R')
source('~/scRNAseq_workflow/code/scrnaseq_workflow_QC.R')
plot_MT_QC(sce,mt_threshold)
source('~/scRNAseq_workflow/code/scrnaseq_workflow_QC.R')
plot_MT_QC(sce,mt_threshold)
sce$keep_manual = (   !cell_filter_by_feature_count(counts(sce),2^min_genes) &
!cell_filter_by_total_UMI(counts(sce),2^min_UMI) &                                !cell_filter_by_mt_content(sce$pct_counts_feature_controls_MT,mt_threshold))
sce$keep_manual = (   !cell_filter_by_feature_count(counts(sce),2^min_genes) &
!cell_filter_by_total_UMI(counts(sce),2^min_UMI) &                                !cell_filter_by_mt_content(sce$pct_counts_MT,mt_threshold))
table(sce$keep_manual)
sce_clean = sce[,sce$keep_manual]
n_th = 1
min_counts = 2
keep_feature = !(gene_filter_by_feature_count(counts(sce_clean),n_th, min_counts))
sce_clean = sce_clean[keep_feature,]
sce_clean = calculateQCMetrics(sce_clean,feature_controls = list(MT=which(fData(sce_clean)$chr=="MT")))
sce_clean = calculateQCMetrics(sce_clean,feature_controls = list(MT=which(rowData(sce_clean)$chr=="MT")))
# The variables used to detect outliers
vars = c( "pct_counts_top_100_features",
"total_features", "pct_counts_feature_controls",
"log10_counts_endogenous_features",
"log10_counts_feature_controls")
sce_clean = plotPCA(sce_clean,
size_by = "total_features",
pca_data_input = "pdata",
selected_variables = vars,
detect_outliers = TRUE,
return_SCESet = TRUE)
table(sce_clean$outlier)
#here, we remove the outliers
sce_clean = sce_clean[,!sce_clean$outlier]
?plotPCA
n_th = 1
min_counts = 2
keep_feature = !(gene_filter_by_feature_count(counts(sce_clean),n_th, min_counts))
sce$keep_manual = (   !cell_filter_by_feature_count(counts(sce),2^min_genes) &
!cell_filter_by_total_UMI(counts(sce),2^min_UMI) &                                !cell_filter_by_mt_content(sce$pct_counts_MT,mt_threshold))
table(sce$keep_manual)
sce_clean = sce[,sce$keep_manual]
n_th = 1
min_counts = 2
keep_feature = !(gene_filter_by_feature_count(counts(sce_clean),n_th, min_counts))
sce_clean = sce_clean[keep_feature,]
sce_clean = calculateQCMetrics(sce_clean,feature_controls = list(MT=which(rowData(sce_clean)$chr=="MT")))
save(sce_clean, file = file.path(out_data_dir,"sce_clean.RData"))
p = my_plot_PCA(counts = log2(counts(sce_clean)+1),
scale_pca = T, center_pca = T, return_pca = F, use_irlba=F,
color = pData(sce_clean)[,"total_features",drop=F])
p = my_plot_PCA(counts = log2(counts(sce_clean)+1),
scale_pca = T, center_pca = T, return_pca = F, use_irlba=F,
color = colData(sce_clean)[,"total_features_by_counts",drop=F])
p = p+ggtitle("PCA on raw log2(counts)")
print(p)
p = my_plot_tSNE(counts = log2(counts(sce_clean)+1),
is_distance = F, scale_pca = F, n_comp = 50, return_tsne=F,
color = colData(sce_clean)[,"total_features_by_counts",drop=F])
p = p+ggtitle("t-SNE on raw log2(counts)")
print(p)
?normalizeExprs
?computeSumFactors
browseVignettes("scran")
# normalize data
sce_clean = normalize_counts(sce_clean,method = "scran")
# normalize data
sce_clean = normalize_counts(sce_clean,method = "TC")
?scater::normalise
source('~/scRNAseq_workflow/code/scrnaseq_workflow_Normalization.R')
# normalize data
sce_clean = normalize_counts(sce_clean,method = "scran")
# normalized values are automatically log2-transformed and
# stored in the norm_exprs slot of the SCESet
norm_exprs(sce_clean)[1:5,1:5]
# normalized values are automatically log2-transformed and
# stored in the norm_exprs slot of the SCESet
exprs(sce_clean)[1:5,1:5]
#calculate size factors according to method
switch(method,
"TC" ={sce = normalizeExprs(sce, method="none",return_norm_as_exprs=T)},
"RLE" = {sce = normalizeExprs(sce, method="RLE",return_norm_as_exprs=T)},
"TMM" = {sce = normalizeExprs(sce, method="TMM",return_norm_as_exprs=T)},
"UQ" = {sce = normalizeExprs(sce, method="upperquartile",return_norm_as_exprs=T)},
"scran" = {clusters = quickCluster(sce)
sizes = seq(20,100,5)
if(min(table(clusters))>max(sizes)){
sce = computeSumFactors(sce,clusters = clusters,sizes=sizes)
} else{
message("Clustering of cells failed, using global scaling factors")
sce = computeSumFactors(sce)
if(any(sizeFactors(sce) < 0)) {
warning("Negative size factors generated. Most likely, this is due to some cells having very low total feature counts. Consider using more stringent QC cutoffs.")
}
}
sce = scater::normalize(sce)
norm_exprs(sce) = logcounts(sce)}
)
source('~/scRNAseq_workflow/code/scrnaseq_workflow_Normalization.R')
# normalize data
sce_clean = normalize_counts(sce_clean,method = "scran")
# normalized values are automatically log2-transformed and
# stored in the norm_exprs slot of the SCESet
norm_exprs(sce_clean)[1:5,1:5]
save(sce_clean, file = file.path(out_data_dir,"sce_clean.RData"))
cd20 = t(norm_exprs(sce_clean["ENSG00000156738",]))
colnames(cd20) = "CD20"
go_id = "GO:0002376"
ens_go = GO_to_gene(go_id)
info_GO = rownames(sce_clean)%in%ens_go
table(info_GO)
p = my_plot_PCA(counts = norm_exprs(sce_clean[info_GO,]),
return_pca = F, scale_pca = T, center_pca = T,
title = "PCA - GO:0002376 features",
color = cd20)
print(p)
info_HVG = info.genes(2^norm_exprs(sce_clean)-1,PLOT=T,qcv=0.25,pv=.1,q=.5,minBiolDisp = 0)
table(info_HVG)
p = my_plot_PCA(counts = norm_exprs(sce_clean[info_HVG,]),
return_pca = F, scale_pca = T, center_pca = T,
title = "PCA - HVG features",
color = cd20)
print(p)
p
info_NBdrop = run_DANB(counts(sce_clean),method = "NBDrop",save_plot=F, cutoff = 0.1)
info_NBdisp = run_DANB(counts(sce_clean),method = "NBDisp",save_plot=F, perc_genes = 10)
info_NBdrop = run_DANB(counts(sce_clean),method = "NBDrop",save_plot=F, cutoff = 0.1)
# fitting the dropout model (DANB)
fit = NBumiFitModel(counts) #this fits a DANB model
fit$mus = t(sapply(fit$vals$tjs, function (x) x * fit$vals$tis/fit$vals$total))
size_coeffs = NBumiFitDispVsMean(fit, suppress.plot = T)#get coefcients of mean-dispersion fit
smoothed_size = exp(size_coeffs[1] + size_coeffs[2] * log(fit$vals$tjs/fit$vals$nc)) #predicted dispersions per gene
size_mat = matrix(rep(smoothed_size, times = fit$vals$nc), ncol = fit$vals$nc, byrow = FALSE)
exp_ps  =  (1 + fit$mus/size_mat)^(-size_mat) #these are the fitted values per cell and gene
exp_tot = rowSums(exp_ps) #this is the total predicted molecules per gene
plot_dt = data.table(Dropout_rate = fit$vals$djs/fit$vals$nc,
expression = fit$vals$tjs/fit$vals$nc,
sizes = fit$sizes,
pred_sizes = smoothed_size,
predicted_dropouts=exp_tot/fit$vals$nc)
NBumiCheckFitFS(counts,fit,suppress.plot = T) #check whether the fitted droout rates are well correlated with observed ones (i.e. number of zeroes)
pvals = NBumiFeatureSelectionCombinedDrop(fit) #ranks genes by difference from expected dropout rates
pvals
head(pvals)
pvals = NBumiFeatureSelectionCombinedDrop(fit)$q.value #ranks genes by difference from expected dropout rates
cutoff = 0.05
info = rownames(counts)%in%names(pvals[which(pvals<cutoff)]) #select the top features based on dropout rates
plot_dt[,info:=info]
p = ggplot(plot_dt,aes(x=log10(expression),y=Dropout_rate)) +
geom_point(aes(color=info),alpha=0.7,size=2) +
geom_line(aes(x=log10(expression),y=predicted_dropouts),color=colors()[30],size=1.2)+
theme_bw() + xlab("Expression [log10]") + ylab("Dropout Rate")+
ggtitle("Dropout rate vs. Expression")+ theme(text = element_text(size=17))+
scale_color_manual(values = colors()[c(226,32)],name="is_outlier")
print(p)
table(info)
names(pvals)
selection = NBumiFeatureSelectionCombinedDrop(fit) #ranks genes by difference from expected dropout rates
pvals = selection$q.value
names(pvals) = selection$Gene
info = rownames(counts)%in%names(pvals[which(pvals<cutoff)]) #select the top features based on dropout rates
plot_dt[,info:=info]
p = ggplot(plot_dt,aes(x=log10(expression),y=Dropout_rate)) +
geom_point(aes(color=info),alpha=0.7,size=2) +
geom_line(aes(x=log10(expression),y=predicted_dropouts),color=colors()[30],size=1.2)+
theme_bw() + xlab("Expression [log10]") + ylab("Dropout Rate")+
ggtitle("Dropout rate vs. Expression")+ theme(text = element_text(size=17))+
scale_color_manual(values = colors()[c(226,32)],name="is_outlier")
print(p)
table(info)
info = rownames(counts)%in%names(pvals[which(pvals<cutoff)]) #select the top features based on dropout rates
plot_dt[,info:=info]
p = ggplot(plot_dt,aes(x=log10(expression),y=Dropout_rate)) +
geom_point(aes(color=info),alpha=0.7,size=2) +
geom_line(aes(x=log10(expression),y=predicted_dropouts),color=colors()[30],size=1.2)+
theme_bw() + xlab("Expression [log10]") + ylab("Dropout Rate")+
ggtitle("Dropout rate vs. Expression")+ theme(text = element_text(size=17))+
scale_color_manual(values = colors()[c(226,32)],name="is_outlier")
print(p)
table(plot_dt$info)
plot_dt$info = info
p = ggplot(plot_dt,aes(x=log10(expression),y=Dropout_rate)) +
geom_point(aes(color=info),alpha=0.7,size=2) +
geom_line(aes(x=log10(expression),y=predicted_dropouts),color=colors()[30],size=1.2)+
theme_bw() + xlab("Expression [log10]") + ylab("Dropout Rate")+
ggtitle("Dropout rate vs. Expression")+ theme(text = element_text(size=17))+
scale_color_manual(values = colors()[c(226,32)],name="is_outlier")
print(p)
source('~/scRNAseq_workflow/vignettes/../code/scrnaseq_workflow_Feature_Selection.R')
info_NBdrop = run_DANB(counts(sce_clean),method = "NBDrop",save_plot=F, cutoff = 0.1)
info_NBdisp = run_DANB(counts(sce_clean),method = "NBDisp",save_plot=F, perc_genes = 10)
table(info_NBdrop,info_NBdisp)
p = my_plot_PCA(counts = norm_exprs(sce_clean[info_NBdrop,]),
return_pca = F, scale_pca = T, center_pca = T,
title = "PCA - NBDrop features",
color = cd20)
print(p)
p = my_plot_PCA(counts = norm_exprs(sce_clean[info_NBdisp,]),
return_pca = F, scale_pca = T, center_pca = T,
title = "PCA - NBDisp features",
color = cd20)
print(p)
sce_info = sce_clean[info_NBdrop,]
dim(sce_info)
# tSNE map of the cleaned data
# note that by setting return_tsne = T, we can obtain the t-SNE object for later use
set.seed(17) #set seed again, some packages internally set a different one
tsne_info = my_plot_tSNE(counts = norm_exprs(sce_info),
scale_pca = F, n_comp = 50, return_tsne=T)$tsne
save(sce_info, file = file.path(out_data_dir,"sce_info.RData"))
save(tsne_info,file = file.path(out_data_dir,"tsne_info.RData"))
b_cell = t(norm_exprs(sce_info["ENSG00000156738",]))
colnames(b_cell) = "B-cell"
monocyte = data.frame(Monocyte = colSums(norm_exprs(sce_info)[which(fData(sce_info)$symbol %in% c('CD14','LYZ','FCGR3A','MS4A7')),]))
b_cell = t(norm_exprs(sce_info["ENSG00000156738",]))
colnames(b_cell) = "B-cell"
monocyte = data.frame(Monocyte = colSums(norm_exprs(sce_info)[which(rowData(sce_info)$symbol %in% c('CD14','LYZ','FCGR3A','MS4A7')),]))
t_cell = data.frame(`T-cell` = colSums(norm_exprs(sce_info)[which(rowData(sce_info)$symbol %in% c('CD3E','CD3D','CD3G')),]))
nk_cell = data.frame(`NK cell` = colSums(norm_exprs(sce_info)[which(rowData(sce_info)$symbol %in% c('GNLY','NKG7')),]))
# Make plots
# Note that by providing the tsne input variable instead of counts,
# we can use an existing t-SNE calculation for plotting
p1 = my_plot_tSNE(tsne = tsne_info, color = b_cell, title = "B-cell marker expression")
p2 = my_plot_tSNE(tsne = tsne_info, color = monocyte, title = "Monocyte marker expression")
p3 = my_plot_tSNE(tsne = tsne_info, color = t_cell, title = "T-cell marker expression")
p4 = my_plot_tSNE(tsne = tsne_info, color = nk_cell, title = " NK cell marker expression")
ggmultiplot(p1,p2,p3,p4,cols=2)
assignment = data.table(tsne1 = tsne_info$Y[,1], tsne2 = tsne_info$Y[,2],cell_type = 'T-cell')
assignment[tsne1 < -10 ,cell_type:='B-cell']
assignment[tsne1 > 5 ,cell_type:='Monocyte']
assignment[tsne2 < -15 & tsne1 > 1,cell_type:='NK Cell']
sce_info$cell_type = assignment$cell_type
p = my_plot_tSNE(tsne = tsne_info, color = pData(sce_info)[,"cell_type",drop=F])
p = my_plot_tSNE(tsne = tsne_info, color = colData(sce_info)[,"cell_type",drop=F])
print(p+labs(title="t-SNE on informative genes",subtitle = "Colored by manual cell annotation"))
assignment = data.table(tsne1 = tsne_info$Y[,1], tsne2 = tsne_info$Y[,2],cell_type = 'T-cell')
assignment[tsne1 < -10 ,cell_type:='Monocyte']
assignment[tsne2 > 20 ,cell_type:='B-cell']
assignment[tsne2 < -15 & tsne1 > 1,cell_type:='NK Cell']
sce_info$cell_type = assignment$cell_type
p = my_plot_tSNE(tsne = tsne_info, color = colData(sce_info)[,"cell_type",drop=F])
print(p+labs(title="t-SNE on informative genes",subtitle = "Colored by manual cell annotation"))
assignment = data.table(tsne1 = tsne_info$Y[,1], tsne2 = tsne_info$Y[,2],cell_type = 'T-cell')
assignment[tsne1 < -10 ,cell_type:='Monocyte']
assignment[tsne2 > 13 ,cell_type:='B-cell']
assignment[tsne2 < -15 & tsne1 > 1,cell_type:='NK Cell']
sce_info$cell_type = assignment$cell_type
p = my_plot_tSNE(tsne = tsne_info, color = colData(sce_info)[,"cell_type",drop=F])
print(p+labs(title="t-SNE on informative genes",subtitle = "Colored by manual cell annotation"))
save(sce_info, file = file.path(out_data_dir,"sce_info.RData"))
save(tsne_info,file = file.path(out_data_dir,"tsne_info.RData"))
